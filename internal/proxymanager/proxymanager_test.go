package proxymanager_test

import (
	"context"
	"flag"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/ubuntu/adsys/internal/proxymanager"
	"github.com/ubuntu/adsys/internal/testutils"
)

func TestNew(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		config proxymanager.Config

		wantErr bool
	}{
		"No options set":   {config: proxymanager.Config{}},
		"HTTP option set":  {config: proxymanager.Config{HTTPProxy: "http://example.com:8080"}},
		"Some options set": {config: proxymanager.Config{HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080"}},
		"All options set": {config: proxymanager.Config{
			HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080",
			FTPProxy: "ftp://example.com:8080", SocksProxy: "socks://example.com:8080",
			NoProxy: "localhost,127.0.0.1",
		}},

		// Error cases
		"Error on unparsable URI": {config: proxymanager.Config{HTTPSProxy: "http://pro\x7Fy:3128"}, wantErr: true},
		"Error on missing scheme": {config: proxymanager.Config{FTPProxy: "example.com:8080"}, wantErr: true},
	}
	for name, tc := range tests {
		tc := tc
		name := name
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			_, err := proxymanager.New(context.Background(), tc.config)
			if tc.wantErr {
				// We don't return here as we want to check that the apparmor
				// dir is in the expected state even in error cases
				require.Error(t, err, "New should have failed but didn't")
				return
			}
			require.NoError(t, err, "New failed but shouldn't have")
		})
	}
}

func TestApply(t *testing.T) {
	t.Parallel()

	envConfigPath := filepath.Join("environment.d", "99adsys-proxy.conf")
	initialTime := time.Date(2001, 1, 1, 1, 1, 1, 1, time.UTC)

	tests := map[string]struct {
		config proxymanager.Config

		existingDirs       []string
		prevContents       map[string]string
		readOnlyFiles      []string
		wantUnchangedFiles []string

		wantErr bool
	}{
		"No options set":   {config: proxymanager.Config{}},
		"HTTP option set":  {config: proxymanager.Config{HTTPProxy: "http://example.com:8080"}},
		"Some options set": {config: proxymanager.Config{HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080"}},
		"Some options set, environment parent directories are created": {
			config:       proxymanager.Config{HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080"},
			existingDirs: []string{},
		},
		"Some options set, environment file is unchanged": {
			wantUnchangedFiles: []string{envConfigPath},
			config:             proxymanager.Config{HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080"},
			prevContents: map[string]string{envConfigPath: `### This file was generated by ADSys - manual changes will be overwritten
HTTP_PROXY=http://example.com:8080
http_proxy=http://example.com:8080
HTTPS_PROXY=https://example.com:8080
https_proxy=https://example.com:8080
`},
		},
		"All options set": {config: proxymanager.Config{
			HTTPProxy: "http://example.com:8080", HTTPSProxy: "https://example.com:8080",
			FTPProxy: "ftp://example.com:8080", SocksProxy: "socks://example.com:8080",
			NoProxy: "localhost,127.0.0.1",
		}},
		"Password is escaped":                          {config: proxymanager.Config{HTTPProxy: "http://username:p@$$:w0rd@example.com:8080"}},
		"Escaped password is not escaped again":        {config: proxymanager.Config{HTTPProxy: "http://username:p%40$$%3Aw0rd@example.com:8080"}},
		"Domain username is escaped":                   {config: proxymanager.Config{HTTPProxy: `http://EXAMPLE\bobsmith:p@$$:w0rd@example.com:8080`}},
		"Domain username without password is escaped":  {config: proxymanager.Config{HTTPProxy: `http://EXAMPLE\bobsmith@example.com:8080`}},
		"Escaped domain username is not escaped again": {config: proxymanager.Config{HTTPProxy: `http://EXAMPLE%5Cbobsmith@example.com:8080`}},

		// Error cases
		"Environment config file is read-only": {readOnlyFiles: []string{envConfigPath}, prevContents: map[string]string{envConfigPath: "something"}, wantErr: true},
	}
	for name, tc := range tests {
		tc := tc
		name := name
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			if tc.existingDirs == nil {
				tc.existingDirs = []string{filepath.Dir(envConfigPath)}
			}

			tmpdir := t.TempDir()
			for _, p := range tc.existingDirs {
				err := os.MkdirAll(filepath.Join(tmpdir, p), 0700)
				require.NoError(t, err, "Setup: Couldn't create %s", p)
			}

			for p, c := range tc.prevContents {
				err := os.WriteFile(filepath.Join(tmpdir, p), []byte(c), 0600)
				require.NoError(t, err, "Setup: Couldn't write previous contents to %q", p)

				err = os.Chtimes(filepath.Join(tmpdir, p), time.Now().UTC(), initialTime)
				require.NoError(t, err, "Setup: Couldn't change mtime for %q", p)
			}

			for _, file := range tc.readOnlyFiles {
				testutils.MakeReadOnly(t, filepath.Join(tmpdir, file))
			}

			p, err := proxymanager.New(context.Background(), tc.config,
				proxymanager.WithEnvironmentConfigPath(filepath.Join(tmpdir, envConfigPath)))
			require.NoError(t, err, "Setup: New failed but shouldn't have")

			err = p.Apply(context.Background())
			if tc.wantErr {
				require.Error(t, err, "Apply should have failed but didn't")
				return
			}
			require.NoError(t, err, "Apply failed but shouldn't have")

			got, err := os.ReadFile(filepath.Join(tmpdir, envConfigPath))
			require.NoError(t, err, "Setup: Failed to read environment config file")
			want := testutils.LoadWithUpdateFromGolden(t, string(got), testutils.WithGoldenPath(testutils.GoldenPath(t)))
			require.Equal(t, want, string(got), "Environment config file content doesn't match")

			for _, file := range tc.wantUnchangedFiles {
				fi, err := os.Stat(filepath.Join(tmpdir, file))
				require.NoError(t, err, "Setup: Failed to stat environment config file")
				require.Equal(t, initialTime, fi.ModTime().UTC(), "Environment config file was modified")
			}
		})
	}
}

func TestMain(m *testing.M) {
	testutils.InstallUpdateFlag()
	flag.Parse()

	m.Run()
}
